<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3S VR Experience</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        #enterVR {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 18px;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: all 0.3s;
        }
        
        #enterVR:hover {
            background: #45a049;
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 1000;
        }
        
        #info h2 {
            margin-top: 0;
            color: #4CAF50;
        }
        
        #compatibility {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px;
            background: rgba(255,255,255,0.9);
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
        
        .compatible {
            color: green;
        }
        
        .incompatible {
            color: red;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Quest 3S VR World</h2>
        <p>Welcome to your VR experience!</p>
        <p><strong>Controls:</strong></p>
        <ul>
            <li>Look around to explore</li>
            <li>Point at cubes to highlight</li>
            <li>Trigger to interact</li>
        </ul>
    </div>
    
    <div id="compatibility"></div>
    <button id="enterVR">Enter VR</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Check WebXR support
        const checkXRSupport = async () => {
            const compatDiv = document.getElementById('compatibility');
            if ('xr' in navigator) {
                try {
                    const isVRSupported = await navigator.xr.isSessionSupported('immersive-vr');
                    if (isVRSupported) {
                        compatDiv.innerHTML = '<span class="compatible">✓ WebXR VR Supported</span>';
                        return true;
                    } else {
                        compatDiv.innerHTML = '<span class="incompatible">✗ WebXR VR Not Supported</span>';
                        return false;
                    }
                } catch (e) {
                    compatDiv.innerHTML = '<span class="incompatible">✗ WebXR Check Failed</span>';
                    return false;
                }
            } else {
                compatDiv.innerHTML = '<span class="incompatible">✗ WebXR Not Available</span>';
                return false;
            }
        };

        // Global variables
        let scene, camera, renderer;
        let controller1, controller2;
        let cubes = [];
        let particles;
        let raycaster;
        let currentSession = null;

        // Initialize Three.js scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101025);
            scene.fog = new THREE.Fog(0x101025, 10, 50);

            // Create camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 3);

            // Create renderer with WebXR enabled
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            scene.add(directionalLight);

            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x222244,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Create grid
            const gridHelper = new THREE.GridHelper(30, 30, 0x444488, 0x222244);
            scene.add(gridHelper);

            // Create interactive cubes
            const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const colors = [0xff0066, 0x00ff66, 0x66ff00, 0xff6600, 0x00ffff, 0xff00ff];
            
            for (let i = 0; i < 6; i++) {
                const cubeMaterial = new THREE.MeshStandardMaterial({
                    color: colors[i],
                    roughness: 0.3,
                    metalness: 0.6,
                    emissive: colors[i],
                    emissiveIntensity: 0.2
                });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.position.x = Math.cos(i * Math.PI / 3) * 2;
                cube.position.y = 1;
                cube.position.z = Math.sin(i * Math.PI / 3) * 2;
                cube.castShadow = true;
                cube.receiveShadow = true;
                cube.userData.originalColor = colors[i];
                cube.userData.rotationSpeed = 0.01 + Math.random() * 0.02;
                cubes.push(cube);
                scene.add(cube);
            }

            // Create particle system for atmosphere
            const particleCount = 1000;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                particlePositions[i] = (Math.random() - 0.5) * 20;
                particlePositions[i + 1] = Math.random() * 10;
                particlePositions[i + 2] = (Math.random() - 0.5) * 20;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x8888ff,
                size: 0.05,
                transparent: true,
                opacity: 0.6
            });
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // Create central sphere
            const sphereGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: 0x4444ff,
                roughness: 0.2,
                metalness: 0.8,
                emissive: 0x222288,
                emissiveIntensity: 0.5
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.y = 1;
            sphere.castShadow = true;
            scene.add(sphere);

            // Add floating rings
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(1.5 + i * 0.5, 0.1, 16, 100);
                const ringMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8888ff,
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: 0x4444ff,
                    emissiveIntensity: 0.3
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = 2 + i * 0.5;
                ring.rotation.x = Math.PI / 2;
                ring.userData.rotationSpeed = 0.005 * (i + 1);
                scene.add(ring);
            }

            // Setup VR controllers
            controller1 = renderer.xr.getController(0);
            scene.add(controller1);

            controller2 = renderer.xr.getController(1);
            scene.add(controller2);

            // Add controller models (simple spheres for now)
            const controllerGeometry = new THREE.SphereGeometry(0.05);
            const controllerMaterial = new THREE.MeshStandardMaterial({ color: 0xffff00 });
            
            const controllerMesh1 = new THREE.Mesh(controllerGeometry, controllerMaterial);
            controller1.add(controllerMesh1);
            
            const controllerMesh2 = new THREE.Mesh(controllerGeometry, controllerMaterial);
            controller2.add(controllerMesh2);

            // Add ray for pointing
            const rayGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, -5)
            ]);
            const rayMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
            const ray1 = new THREE.Line(rayGeometry, rayMaterial);
            controller1.add(ray1);
            
            const ray2 = new THREE.Line(rayGeometry.clone(), rayMaterial);
            controller2.add(ray2);

            // Raycaster for interactions
            raycaster = new THREE.Raycaster();

            // Controller events
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);

            // Window resize handler
            window.addEventListener('resize', onWindowResize);
        }

        function onSelectStart(event) {
            const controller = event.target;
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            
            const rayDirection = new THREE.Vector3(0, 0, -1);
            rayDirection.applyMatrix4(tempMatrix);
            
            raycaster.set(controller.position, rayDirection);
            const intersects = raycaster.intersectObjects(cubes);
            
            if (intersects.length > 0) {
                const selectedCube = intersects[0].object;
                selectedCube.material.emissiveIntensity = 0.8;
                selectedCube.scale.set(1.2, 1.2, 1.2);
                
                // Add a pulse effect
                const originalScale = 1.2;
                const pulseAnimation = setInterval(() => {
                    const scale = originalScale + Math.sin(Date.now() * 0.005) * 0.1;
                    selectedCube.scale.set(scale, scale, scale);
                }, 16);
                selectedCube.userData.pulseAnimation = pulseAnimation;
            }
        }

        function onSelectEnd(event) {
            cubes.forEach(cube => {
                cube.material.emissiveIntensity = 0.2;
                cube.scale.set(1, 1, 1);
                if (cube.userData.pulseAnimation) {
                    clearInterval(cube.userData.pulseAnimation);
                    cube.userData.pulseAnimation = null;
                }
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(time) {
            // Rotate cubes
            cubes.forEach((cube, index) => {
                cube.rotation.x += cube.userData.rotationSpeed;
                cube.rotation.y += cube.userData.rotationSpeed;
                cube.position.y = 1 + Math.sin(time * 0.001 + index) * 0.2;
            });

            // Rotate particles
            if (particles) {
                particles.rotation.y += 0.0005;
            }

            // Animate rings
            scene.traverse((child) => {
                if (child.geometry instanceof THREE.TorusGeometry) {
                    child.rotation.z += child.userData.rotationSpeed || 0;
                    child.position.y = child.position.y + Math.sin(time * 0.001) * 0.001;
                }
            });

            // Animate central sphere
            const sphere = scene.children.find(child => 
                child.geometry instanceof THREE.SphereGeometry
            );
            if (sphere) {
                sphere.rotation.y += 0.01;
                sphere.scale.setScalar(1 + Math.sin(time * 0.002) * 0.1);
            }

            renderer.render(scene, camera);
        }

        // VR Session management
        async function onSessionStarted(session) {
            currentSession = session;
            session.addEventListener('end', onSessionEnded);
            await renderer.xr.setSession(session);
            document.getElementById('enterVR').textContent = 'Exit VR';
        }

        function onSessionEnded() {
            currentSession.removeEventListener('end', onSessionEnded);
            currentSession = null;
            document.getElementById('enterVR').textContent = 'Enter VR';
        }

        // Initialize everything
        async function start() {
            const vrSupported = await checkXRSupport();
            
            init();
            animate();

            const vrButton = document.getElementById('enterVR');
            
            if (vrSupported) {
                vrButton.addEventListener('click', async () => {
                    if (currentSession === null) {
                        const sessionInit = {
                            optionalFeatures: ['local-floor', 'bounded-floor']
                        };
                        try {
                            const session = await navigator.xr.requestSession('immersive-vr', sessionInit);
                            await onSessionStarted(session);
                        } catch (e) {
                            console.error('Failed to start VR session:', e);
                            alert('Failed to start VR session. Please ensure your Quest is properly connected.');
                        }
                    } else {
                        currentSession.end();
                    }
                });
            } else {
                vrButton.style.display = 'none';
                document.getElementById('info').innerHTML += 
                    '<p style="color: #ff6666;">VR not supported on this device/browser</p>';
            }
        }

        // Start the application
        start();
    </script>
</body>
</html>